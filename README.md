Python for Data Science  
Education
# **Python для Data Science**
Учебные задания на портале GeekBrains.

# Lesson 02. Pandas. NumPy

## Практическое задание NumPy
### Задание 1
1. Импортируйте библиотеку Numpy и дайте ей псевдоним np.
Создать одномерный массив Numpy под названием a из 12 последовательных целых чисел чисел от 12 до 24 невключительно
Создать 5 двумерных массивов разной формы из массива a. Не использовать в аргументах метода reshape число -1.
Создать 5 двумерных массивов разной формы из массива a.
Использовать в аргументах метода reshape число -1 (в трех примерах - для обозначения числа столбцов, в двух - для строк).
Можно ли массив Numpy, состоящий из одного столбца и 12 строк, назвать одномерным?
1. Создать массив из 3 строк и 4 столбцов, состоящий из случайных чисел с плавающей запятой из нормального распределения  со средним, равным 0 и среднеквадратичным отклонением, равным 1.0.
Получить из этого массива одномерный массив с таким же атрибутом size, как и исходный массив.
1. Создать массив a, состоящий из целых чисел, убывающих от 20 до 0 невключительно с интервалом 2.
Создать массив b, состоящий из 1 строки и 10 столбцов: целых чисел, убывающих от 20 до 1 невключительно с интервалом 2.
В чем разница между массивами a и b?
1. Вертикально соединить массивы a и b. a - двумерный массив из нулей, число строк которого больше 1 и на 1 меньше, чем число строк двумерного массива b, состоящего из единиц. Итоговый массив v должен иметь атрибут size, равный 10.
1. Создать одномерный массив а, состоящий из последовательности целых чисел от 0 до 12.
Поменять форму этого массива, чтобы получилась матрица A (двумерный массив Numpy), состоящая из 4 строк и 3 столбцов.
Получить матрицу At путем транспонирования матрицы A.
Получить матрицу B, умножив матрицу A на матрицу At с помощью матричного умножения.
Какой размер имеет матрица B? Получится ли вычислить обратную матрицу для матрицы B и почему?
1. Инициализируйте генератор случайных числе с помощью объекта seed, равного 42.
Создайте одномерный массив c, составленный из последовательности 16-ти случайных равномерно распределенных целых чисел от 0 до 16 невключительно.
Поменяйте его форму так, чтобы получилась квадратная матрица C.
Получите матрицу D, поэлементно прибавив матрицу B из предыдущего вопроса к матрице C, умноженной на 10.
Вычислите определитель, ранг и обратную матрицу D_inv для D.
1. Приравняйте к нулю отрицательные числа в матрице D_inv, а положительные - к единице. Убедитесь, что в матрице D_inv остались только нули и единицы.
С помощью функции numpy.where, используя матрицу D_inv в качестве маски, а матрицы B и C - в качестве источников данных, получите матрицу E размером 4x4.
Элементы матрицы E, для которых соответствующий элемент матрицы D_inv равен 1, должны быть равны соответствующему элементу матрицы B, а элементы матрицы E, для которых соответствующий элемент матрицы D_inv равен 0, должны быть равны соответствующему элементу матрицы C.

### Задание 2
Создайте массив Numpy под названием a размером 5x2, то есть состоящий из 5 строк и 2 столбцов.
Первый столбец должен содержать числа 1, 2, 3, 3, 1, а второй - числа 6, 8, 11, 10, 7.
Будем считать, что каждый столбец - это признак, а строка - наблюдение.
Затем найдите среднее значение по каждому признаку, используя метод mean массива Numpy.
Результат запишите в массив mean_a, в нем должно быть 2 элемента.

### Задание 3
Вычислите массив a_centered, отняв от значений массива а средние значения соответствующих признаков, содержащиеся в массиве mean_a.
Вычисление должно производиться в одно действие.
Получившийся массив должен иметь размер 5x2.

### Задание 4
Найдите скалярное произведение столбцов массива a_centered.
В результате должна получиться величина a_centered_sp.
Затем поделите a_centered_sp на N-1, где N - число наблюдений.

### Задание 5**
Число, которое мы получили в конце задания 3 является ковариацией двух признаков, содержащихся в массиве а. В задании 4 мы делили сумму произведений центрированных признаков на N-1, а не на N, поэтому полученная нами величина является несмещенной оценкой ковариации.
В этом задании проверьте получившееся число, вычислив ковариацию еще одним способом - с помощью функции np.cov.
В качестве аргумента m функция np.cov должна принимать транспонированный массив a.
В получившейся ковариационной матрице (массив Numpy размером 2x2) искомое значение
ковариации будет равно элементу в строке с индексом 0 и столбце с индексом 1.

Подробнее узнать о ковариации можно здесь:
[Ссылка](https://studopedia.ru/9_153900_viborochnaya-kovariatsiya-i-viborochnaya-dispersiya.html)

## Практическое задание тема NumPy
### Задание 1
A. Импортируйте библиотеку Pandas и дайте ей псевдоним pd.  
B. Создайте датафрейм authors со столбцами author_id и author_name, в которых соответственно содержатся данные:
[1, 2, 3] и ['Тургенев', 'Чехов', 'Островский'].  
C. Затем создайте датафрейм book cо столбцами author_id, book_title и price,в которых соответственно содержатся данные:
[1, 1, 1, 2, 2, 3, 3],
['Отцы и дети', 'Рудин', 'Дворянское гнездо', 'Толстый и тонкий', 'Дама с собачкой', 'Гроза', 'Таланты и поклонники'],
[450, 300, 350, 500, 450, 370, 290].

### Задание 2
Получите датафрейм authors_price, соединив датафреймы authors и books по полю author_id.

### Задание 3
Создайте датафрейм top5, в котором содержатся строки из authors_price с пятью самыми дорогими книгами.

### Задание 4
A. Создайте датафрейм authors_stat на основе информации из authors_price.  
B. В датафрейме authors_stat должны быть четыре столбца:
author_name, min_price, max_price и mean_price, в которых должны содержаться соответственно имя автора, минимальная, максимальная и средняя цена на книги этого автора.

### Задание 5
Создайте новый столбец в датафрейме authors_price под названием cover, в нем будут располагаться данные о том, какая обложка у данной книги - твердая или мягкая.
В этот столбец поместите данные из следующего списка:
['твердая', 'мягкая', 'мягкая', 'твердая', 'твердая', 'мягкая', 'мягкая'].
Просмотрите документацию по функции pd.pivot_table с помощью вопросительного знака.
Для каждого автора посчитайте суммарную стоимость книг в твердой и мягкой обложке.Используйте для этого функцию pd.pivot_table. При этом столбцы должны называться "твердая" и "мягкая",а индексами должны быть фамилии авторов. Пропущенные значения стоимостей заполните нулями,при необходимости загрузите библиотеку Numpy.
Назовите полученный датасет book_info и сохраните его в формат pickle под названием "book_info.pkl".Затем загрузите из этого файла датафрейм и назовите его book_info2.Удостоверьтесь, что датафреймы book_info и book_info2 идентичны

# Lesson 04. Визуализация данных в Matplotlib.

### Задание 1
Загрузите модуль pyplot библиотеки matplotlib с псевдонимом plt, а также библиотеку numpy с псевдонимом np.  
Примените магическую функцию %matplotlib inline для отображения графиков в Jupyter Notebook и настройки конфигурации ноутбука со значением 'svg' для более четкого отображения графиков.  
Создайте список под названием x с числами 1, 2, 3, 4, 5, 6, 7 и список y с числами 3.5, 3.8, 4.2, 4.5, 5, 5.5, 7.  
С помощью функции plot постройте график, соединяющий линиями точки с горизонтальными координатами из списка x и вертикальными - из списка y.  
Затем в следующей ячейке постройте диаграмму рассеяния (другие названия - диаграмма разброса, scatter plot).

### Задание 2
С помощью функции linspace из библиотеки Numpy создайте массив t из 51 числа от 0 до 10 включительно.  
Создайте массив Numpy под названием f, содержащий косинусы элементов массива t.  
Постройте линейную диаграмму, используя массив t для координат по горизонтали, а массив f - для координат по вертикали. Линия графика должна быть зеленого цвета.  
Выведите название диаграммы - 'График f(t)'.  
Также добавьте названия для горизонтальной оси - 'Значения t' и для вертикальной - 'Значения f'.  
Ограничьте график по оси x значениями 0.5 и 9.5, а по оси y - значениями -2.5 и 2.5.

### Задание 3
С помощью функции linspace библиотеки Numpy создайте массив x из 51 числа от -3 до 3 включительно.  
Создайте массивы $y_1$, $y_2$, $y_3$, $y_4$ по следующим формулам:  
$$y_1 = x^2$$  
$$y_2 = 2 * x + 0.5$$  
$$y_3 = -3 * x - 1.5$$  
$$y_4 = \sin(x)$$  
Используя функцию subplots модуля matplotlib.pyplot, создайте объект matplotlib.figure.Figure с названием fig и массив объектов Axes под названием ax, причем так, чтобы у вас было 4 отдельных графика в сетке, состоящей из двух строк и двух столбцов. В каждом графике массив x используется для координат по горизонтали.  
В левом верхнем графике для координат по вертикали используйте $y_1$, в правом верхнем - $y_2$, в левом нижнем - $y_3$, в правом нижнем - $y_4$.  
Дайте название графикам: 'График $y_1$', 'График $y_2$' и т.д.  
Для графика в левом верхнем углу установите границы по оси x от -5 до 5.  
Установите размеры фигуры 8 дюймов по горизонтали и 6 дюймов по вертикали.  
Вертикальные и горизонтальные зазоры между графиками должны составлять 0.3.

### Задание 4
В этом задании мы будем работать с датасетом, в котором приведены данные по мошенничеству с кредитными данными:
Credit Card Fraud Detection (информация об авторах: Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015).
Данный датасет является примером несбалансированных данных, так как мошеннические операции с картами встречаются реже обычных.
Импортруйте библиотеку Pandas, а также используйте для графиков стиль “fivethirtyeight”.
Посчитайте с помощью метода value_counts количество наблюдений для каждого значения целевой переменной Class и примените к полученным данным метод plot, чтобы построить столбчатую диаграмму. Затем постройте такую же диаграмму, используя логарифмический масштаб.
На следующем графике постройте две гистограммы по значениям признака V1 - одну для мошеннических транзакций (Class равен 1) и другую - для обычных (Class равен 0). Подберите значение аргумента density так, чтобы по вертикали графика было расположено не число наблюдений, а плотность распределения. Число бинов должно равняться 20 для обеих гистограмм, а коэффициент alpha сделайте равным 0.5, чтобы гистограммы были полупрозрачными и не загораживали друг друга. Создайте легенду с двумя значениями: “Class 0” и “Class 1”. Гистограмма обычных транзакций должна быть серого цвета, а мошеннических - красного. Горизонтальной оси дайте название “Class”.

# Lesson 06. Обучение с учителем в Scikit-learn

## Задание 1
Импортируйте библиотеки pandas и numpy.  
Загрузите "Boston House Prices dataset" из встроенных наборов данных библиотеки sklearn. Создайте датафреймы X и y из этих данных.  
Разбейте эти датафреймы на тренировочные (X_train, y_train) и тестовые (X_test, y_test) с помощью функции train_test_split так, чтобы размер тестовой выборки составлял 30% от всех данных, при этом аргумент random_state должен быть равен 42.  
Создайте модель линейной регрессии под названием lr с помощью класса LinearRegression из модуля sklearn.linear_model.  
Обучите модель на тренировочных данных (используйте все признаки) и сделайте предсказание на тестовых.  
Вычислите R2 полученных предказаний с помощью r2_score из модуля sklearn.metrics.

## Задание 2
Создайте модель под названием model с помощью RandomForestRegressor из модуля sklearn.ensemble.  
Сделайте агрумент n_estimators равным 1000, max_depth должен быть равен 12 и random_state сделайте равным 42.  
Обучите модель на тренировочных данных аналогично тому, как вы обучали модель LinearRegression, но при этом в метод fit вместо датафрейма y_train поставьте y_train.values[:, 0], чтобы получить из датафрейма одномерный массив Numpy, так как для класса RandomForestRegressor в данном методе для аргумента y предпочтительно применение массивов вместо датафрейма.  
Сделайте предсказание на тестовых данных и посчитайте R2. Сравните с результатом из предыдущего задания.  
Напишите в комментариях к коду, какая модель в данном случае работает лучше.  

## * Задание 3
Вызовите документацию для класса RandomForestRegressor,
найдите информацию об атрибуте feature_importances_.  
С помощью этого атрибута найдите сумму всех показателей важности, установите, какие два признака показывают наибольшую важность.

## * Задание 4
В этом задании мы будем работать с датасетом, с которым мы уже знакомы по домашнему заданию по библиотеке Matplotlib, это датасет Credit Card Fraud Detection.  
Для этого датасета мы будем решать задачу классификации - будем определять, какие из транзакциции по кредитной карте являются мошенническими.  
Данный датасет сильно несбалансирован (так как случаи мошенничества относительно редки), так что применение метрики accuracy не принесет пользы и не поможет выбрать лучшую модель.  
Мы будем вычислять AUC, то есть площадь под кривой ROC.  
Импортируйте из соответствующих модулей RandomForestClassifier, GridSearchCV и train_test_split.  
Загрузите датасет creditcard.csv и создайте датафрейм df.  
С помощью метода value_counts с аргументом normalize=True убедитесь в том, что выборка несбалансирована.  
Используя метод info, проверьте, все ли столбцы содержат числовые данные и нет ли в них пропусков.  
Примените следующую настройку, чтобы можно было просматривать все столбцы датафрейма:  
* pd.options.display.max_columns = 100.
* Просмотрите первые 10 строк датафрейма df.
* Создайте датафрейм X из датафрейма df, исключив столбец Class.
* Создайте объект Series под названием y из столбца Class.
* Разбейте X и y на тренировочный и тестовый наборы данных при помощи функции train_test_split, используя аргументы: test_size=0.3, random_state=100, stratify=y.
* У вас должны получиться объекты X_train, X_test, y_train и y_test.
* Просмотрите информацию о их форме.  

Для поиска по сетке параметров задайте такие параметры:  
&nbsp;&nbsp;parameters = [{'n_estimators': [10, 15],  
&nbsp;&nbsp;'max_features': np.arange(3, 5),  
&nbsp;&nbsp;'max_depth': np.arange(4, 7)}]  

Создайте модель GridSearchCV со следующими аргументами:  
&nbsp;&nbsp;estimator=RandomForestClassifier(random_state=100),  
&nbsp;&nbsp;param_grid=parameters,  
&nbsp;&nbsp;scoring='roc_auc',  
&nbsp;&nbsp;cv=3.

Обучите модель на тренировочном наборе данных (может занять несколько минут).  
Просмотрите параметры лучшей модели с помощью атрибута best_params_.  
Предскажите вероятности классов с помощью полученнной модели и метода predict_proba.  
Из полученного результата (массив Numpy) выберите столбец с индексом 1 (вероятность класса 1) и запишите в массив y_pred_proba.  
Из модуля sklearn.metrics импортируйте метрику roc_auc_score.  
Вычислите AUC на тестовых данных и сравните с результатом,полученным на тренировочных данных, используя в качестве аргументов массивы y_test и y_pred_proba.

## * Дополнительные задания:
1. Загрузите датасет Wine из встроенных датасетов sklearn.datasets с помощью функции load_wine в переменную data.  
1. Полученный датасет не является датафреймом. Это структура данных, имеющая ключи аналогично словарю. Просмотрите тип данных этой структуры данных и создайте список data_keys, содержащий ее ключи.
1. Просмотрите данные, описание и названия признаков в датасете. Описание нужно вывести в виде привычного, аккуратно оформленного текста, без обозначений переноса строки, но с самими переносами и т.д.
1. Сколько классов содержит целевая переменная датасета? Выведите названия классов.
1. На основе данных датасета (они содержатся в двумерном массиве Numpy) и названий признаков создайте датафрейм под названием X.
1. Выясните размер датафрейма X и установите, имеются ли в нем пропущенные значения.
1. Добавьте в датафрейм поле с классами вин в виде чисел, имеющих тип данных numpy.int64. Название поля - 'target'.
1. Постройте матрицу корреляций для всех полей X. Дайте полученному датафрейму название X_corr.
1. Создайте список high_corr из признаков, корреляция которых с полем target по абсолютному значению превышает 0.5 (причем, само поле target не должно входить в этот список).
1. Удалите из датафрейма X поле с целевой переменной. Для всех признаков, названия которых содержатся в списке high_corr, вычислите квадрат их значений и добавьте в датафрейм X соответствующие поля с суффиксом '\_2', добавленного к первоначальному названию признака. Итоговый датафрейм должен содержать все поля, которые, были в нем изначально, а также поля с признаками из списка high_corr, возведенными в квадрат. Выведите описание полей датафрейма X с помощью метода describe.

# Lesson 08. Обучение без учителя в Scikit-learn.
## Задание 1
Импортируйте библиотеки pandas, numpy и matplotlib.
Загрузите "Boston House Prices dataset" из встроенных наборов данных библиотеки sklearn.
Создайте датафреймы X и y из этих данных.
Разбейте эти датафреймы на тренировочные (X_train, y_train) и тестовые (X_test, y_test)
с помощью функции train_test_split так, чтобы размер тестовой выборки
составлял 20% от всех данных, при этом аргумент random_state должен быть равен 42.
Масштабируйте данные с помощью StandardScaler.
Постройте модель TSNE на тренировочный данных с параметрами:
n_components=2, learning_rate=250, random_state=42.
Постройте диаграмму рассеяния на этих данных.

## Задание 2
С помощью KMeans разбейте данные из тренировочного набора на 3 кластера,
используйте все признаки из датафрейма X_train.
Параметр max_iter должен быть равен 100, random_state сделайте равным 42.
Постройте еще раз диаграмму рассеяния на данных, полученных с помощью TSNE,
и раскрасьте точки из разных кластеров разными цветами.
Вычислите средние значения price и CRIM в разных кластерах.

## Задание 3 *
Примените модель KMeans, построенную в предыдущем задании,
к данным из тестового набора.
Вычислите средние значения price и CRIM в разных кластерах на тестовых данных.

# Курсовой проект для курса "Python для Data Science"

Материалы к проекту (файлы):
train.csv
test.csv

Задание:
Используя данные из train.csv, построить
модель для предсказания цен на недвижимость (квартиры).
С помощью полученной модели предсказать
цены для квартир из файла test.csv.

Целевая переменная:
Price

Основная метрика:
R2 - коэффициент детерминации (sklearn.metrics.r2_score)

Вспомогательная метрика:
MSE - средняя квадратичная ошибка (sklearn.metrics.mean_squared_error)

Сдача проекта:
1. Прислать в раздел Задания Урока 12 ("Вебинар. Консультация по итоговому проекту")
ссылку на программу в github (программа должна содержаться в файле Jupyter Notebook
с расширением ipynb).
2. Приложить файл с названием по образцу SShirkin_predictions.csv
с предсказанными ценами для квартир из test.csv (файл должен содержать два поля: Id, Price).

Сроки сдачи:
Сдать проект за 72 часа до начала Урока 13 ("Вебинар. Результаты итоговых проектов и закрытие курса").

Примечание:
Все файлы csv должны содержать названия полей (header - то есть "шапку"),
разделитель - запятая. В файлах не должны содержаться индексы из датафрейма.
